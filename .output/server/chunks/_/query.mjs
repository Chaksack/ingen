import{h as r,i as t}from"../nitro/nitro.mjs";import"unist-util-visit";import"hast-util-to-string";import"node:http";import"node:https";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"node:crypto";import"vue";import"consola";import"@unhead/schema-org/vue";import"node:url";import"unified";import"mdast-util-to-string";import"micromark";import"unist-util-stringify-position";import"micromark-util-character";import"micromark-util-chunked";import"micromark-util-resolve-all";import"micromark-util-sanitize-uri";import"slugify";import"remark-parse";import"remark-rehype";import"remark-mdc";import"remark-gfm";import"rehype-external-links";import"rehype-sort-attribute-values";import"rehype-sort-attributes";import"rehype-raw";import"detab";import"github-slugger";import"unhead/server";import"unhead/utils";import"unhead/plugins";import"vue-bundle-renderer/runtime";import"vue/server-renderer";import"ipx";function regExpReviver(r,t){const e="string"==typeof t&&t.match(/^--([A-Z]+) (.+)$/)||[];if("REGEX"===e[1]){const r=e[2]?.match(/\/(.*)\/([dgimsuy]*)$/);return r?.[1]?new RegExp(r[1],r[2]||""):t}return t}const parseJSONQueryParams=r=>{try{return e=r,JSON.parse(e,regExpReviver)}catch{throw t({statusCode:400,message:"Invalid _params query"})}var e},decodeQueryParams=r=>(r=(r=(r=r.replace(/\//g,"")).replace(/-/g,"+").replace(/_/g,"/")).padEnd(r.length+(4-r.length%4)%4,"="),parseJSONQueryParams("undefined"!=typeof Buffer?Buffer.from(r,"base64").toString():atob(r))),e={},getContentQuery=t=>{const{params:i}=t.context.params||{};if(i)return decodeQueryParams(i.replace(/.json$/,""));const o=t.context.params?.qid?.replace(/.json$/,""),p=r(t)||{};if(o&&p._params)return e[o]=parseJSONQueryParams(decodeURIComponent(p._params)),e[o]?.where&&!Array.isArray(e[o]?.where)&&(e[o].where=[e[o].where]),e[o];if(o&&e[o])return e[o];if(p._params)return parseJSONQueryParams(decodeURIComponent(p._params));"string"==typeof p.only&&p.only.includes(",")&&(p.only=p.only.split(",").map(r=>r.trim())),"string"==typeof p.without&&p.without.includes(",")&&(p.without=p.without.split(",").map(r=>r.trim()));const n=p.where||{};for(const r of["draft","partial","empty"])p[r]&&["true","false"].includes(p[r])&&(n[r]="true"===p[r],delete p[r]);p.sort&&(p.sort=String(p.sort).split(",").map(r=>{const[t,e]=r.split(":");return[t,Number.parseInt(e||"0",10)]}));const m=["partial","draft","only","without","where","sort","limit","skip"];for(const r of Object.keys(p))m.includes(r)||(p.where=p.where||{},p.where[r]=p[r]);return Object.keys(n).length>0?p.where=[n]:delete p.where,p};export{decodeQueryParams,getContentQuery};
//# sourceMappingURL=query.mjs.map
